#!/usr/bin/env python3
"""
A websocket server for das streams.  Written in python so we can ride off the 
source definition parsing to determine what command to run.

The trio websocket library handles ping/pong automatically for us (yay!)
"""

import sys
import argparse
import logging
import pathlib
import ssl
import subprocess # For defintions only
from functools import partial as delegate

g_sConfPath = REPLACED_ON_BUILD

import trio
from trio_websocket import serve_websocket, ConnectionClosed
import contextvars

# ########################################################################## #
g_log = None

g_dConfigCache = {} # A cache of json configs, the key is the filesystem path

ServerError       = "InternalServerError"
NoSuchDataSource  = "NoSuchDataSource"
QueryError        = "QueryError"
BadRequest        = "BadRequest"

c_dClient = contextvars.ContextVar("c_dClient")

# ########################################################################## #

def loadConf(sConfPath = None):
	"""Load the dasflex server configuration file.  

	This boiler plate that has to be re-included in each script since the config
	itself cannot be read my module code, since the location of the modules is
	determined by the configuration file.

	The config file is stored with a key of None.  This makes it a singleton.

	Unlike most of the other options, this is not an async function, it's 
	supposed to run to completion when invoked.

	Args:
		sOverRide (str): Read the config from this location instead of the 
			compiled in default

	Returns (dict): Returns the configuration dictionary, and also caches it
		in the Configuration Cache to prevent re-reads for each incomming
		request.
	"""

	global g_dConfigCache

	if not sConfPath: sConfPath = g_sConfPath

	if not os.path.isfile(sConfPath):
		if os.path.isfile(sConfPath + ".example"):
			sMsg = "Move\n     %s.example\nto\n     %s\nto enable your site"%(
			      sConfPath, sConfPath)
		else:
			sMsg = "%s is missing\n"%sConfPath
		
		raise EnvironmentError(sMsg)

	fIn = open(g_sConfPath, 'r')
	
	dConf = {}
	nLine = 0
	for sLine in fIn:
		nLine += 1
		iComment = sLine.find('#')
		if iComment > -1:
			sLine = sLine[:iComment]
	
		sLine = sLine.strip()
		if len(sLine) == 0:
			continue
		
		iEquals = sLine.find('=')
		if iEquals < 1 or iEquals > len(sLine) - 2:
			preLoadError("Error in %s line %d"%(g_sConfPath, nLine))
			fIn.close()
			return None
		
		sKey = sLine[:iEquals].strip()
		sVal = sLine[iEquals + 1:].strip(' \t\v\r\n\'"')
		dConf[sKey] = sVal
	
	fIn.close()
	
	# As finial steps, inclued a reference to the config file itself
	dConf['__file__'] = sConfPath

	# Some replacement text
	if 'SERVER_ID' not in dConf:
		dConf['SERVER_ID'] = "unknown"

	if 'SERVER_NAME' not in dConf:
		dConf['SERVER_NAME'] = "Unknown"

	if 'SITE_CATALOG_TAG' not in dConf:
		dConf['SITE_CATALOG_TAG'] = "tag:unknown.site.org,2021"
	
	g_dConfigCache[None] = dConf

	return g_dConfigCache[None]

##############################################################################
class AsyncLogFile(object):
	"""Replicates the functionality of the prepender script for the perl server
	using trio calls
	"""

	def __init__(self, sDir=None, sRmtAddr="direct_invoke"):
		"""Arguments: Log directory and remote client address"""
		
		if sDir == None or not os.path.isdir(sDir):
			self._file = sys.stderr
		else:
			nSuffix = (int(time.time()) / 86400) % 3
			sLogFile = 'das2.%s_%d.log'%(sRmtAddr, nSuffix)
			sLogPath = pjoin( sDir, sLogFile)
			self._file = open(sLogPath, 'a')
			
		self.sPrefix = "%s %d"%(time.asctime(), os.getpid())
		self.nLine = 0
		
	def newPrefix(self):
		self.sPrefix = "%s %d"%(time.asctime(), os.getpid())
		self.nLine = 0
		
	def fileno(self):
		return self._file.fileno()
		
	def write(self, sMsg):
	
		lMsg = sMsg.split(u'\n')
			
		for sLine in lMsg:
			if len(sLine.strip()) > 0:

				sOut = '[%s %4d] %s\n'%(self.sPrefix, self.nLine, sLine)
				self._file.buffer.write(sOut.encode('utf-8'))
				self.nLine += 1

		self._file.flush()
		
	def close(self):
		if self._file != sys.stderr:
			self._file.close()

# ########################################################################## #

def _xmlEscape(sMsg):
	sMsg = sMsg.replace(u'\n', u'&#13;&#10;').replace(u'"', u"'")
	sMsg = sMsg.replace(u'<', u'&lt;').replace(u'>',u'&gt;')
	return sMsg

class RequestError(Exception):
	def __init__(self, sType, sMsg):
		self.status = None
		self.headers = [('Content-Type','text/vnd.das2.stream')]
		self.body = None
		if sType == NoSuchDataSource:
			self.status = 404
		elif sType == QueryError:  
			self.status = 422            # Unprocessable entity
		else:
			self.status = 400

		l = [('Sx', "\n<stream version=\"3.0\" type=\"das-basic-stream\"/>\n")]
		l.append( ('Ex', "\n<exception type=\"%s\">\n\t%s\n</exception>\n"%(
			_xmlEscape(sType), _xmlEscape(sMsg)
		)))

		ll = [ "%s||%d|%s"%(t[0], len(t[1].encode('utf-8')), t[1]) for t in l]
		self.body = b''.join( [s.encode('utf-8') for s in ll ])

# ########################################################################## #

async def getReaderCmd(request):
	"""Return the reader command line, or throw a connection exception"""
	
	dConf = g_dConfigCache[None]

	sSrc = request.path

	dQuery = {}
	i = sSrc.find('?')
	if i > 2:
		#g_log.info("Query String is: %s"%(sSrc[i+1:].strip()))
		sQuery = sSrc[i+1:].strip()
		sSrc = sSrc[:i]
		if len(sQuery) > 3:
			lQuery = [s.strip() for s in sQuery.split('&')]
			#g_log.info("Query pairs are: %s", lQuery)
			for sPair in lQuery:
				j = sPair.find('=');
				if j > 2:
					dQuery[ sPair[:j].strip() ] = sPair[j+1:].strip()
		
	if len(sSrc) > 128: sSrc = sSrc[:128]

	# Check to see that this is one of ours
	for sTmp in ('WEBSOCKET_URI','DATASRC_ROOT'):
	if sTmp not in dConf:
		raise RequestError(ServerError, "%s missing in config file"%sTmp);
	
	sRootUri = dConf['WEBSOCKET_URI']
	if sRootUri[-1] != '/': sRootUri = sRootUri + '/'
	if not sSrc.startswith(sRootUri):
		raise RequestError(NoSuchDataSource, "Data source %s is not defined on this server"%sSrc);
	sSrc = sSrc.replace(sRootUri,'')

	# '/tracers/l0/msc/em1/sci/data':
	lSrc = sSrc.split('/')
	if (len(lSrc) < 2) or (lSrc[-1] != 'flexRT'):
		raise RequestError(NoSuchDataSource, "Data source %s is not defined on this server"%sSrc);		

	sLocalId = '/'.join(lSrc[:-1])

	dIntern = getInternal(sLocalId)

	g_log.info("Read from: %s"%lSrc)
	if (len(lSrc) == 7) and sSrc.startswith('/tracers/l0'):
		sInst = lSrc[3]
		sModel = lSrc[4]
		sKind  = lSrc[5]	
		g_log.info("Kind = %s, Instrument = %s, Model = %s"%(sKind, sModel, sKind))
		
		for sExpect in ('read.time.min', 'read.time.max'):
			if sExpect not in dQuery:
				raise RequestError(QueryError, "Expected query key %s missing"%sExpect)
		
		sCmd = "tis_l1db_das -k %s %s %s %s %s"%(
			sKind, sInst, sModel, dQuery['read.time.min'], dQuery['read.time.max']
		)
		return (sCmd, False) # False = no keepalive
	
	elif sSrc == '/tracers/l0/msc/em1/sci-psd/data':
		sFile = 'tra-preflight_L0_msc-em1_x242-psd_20220309_v1.0.0.d3s'
		return ("cat %s/%s"%(sDir, sFile), False)
		
	else:
		raise RequestError(NoSuchDataSource, 
"""Data source %s does not exist on this server. 
Hint: the following paths are defined:
	/tracers/l0/msc/em1/sci/data
   /tracers/l0/msc/em1/sci-psd/data
"""%sSrc);

	return (" ".join(lCmd), False)  # Standard read-to-end sources for now

def setModulePath(dConf):
	if 'MODULE_PATH' not in dConf:
		preLoadError("Set MODULE_PATH = /dir/containing/dasflex_python_module")
		return False	
	
	lDirs = dConf['MODULE_PATH'].split(':') # No mater the os.pathsep setting
	for sDir in lDirs:
		if os.path.isdir(sDir):
				if sDir not in sys.path:
					sys.path.insert(0, sDir)
		
	return True

# ########################################################################## #

async def DelClientMsg(ws):
	while True:
		await ws.get_message();

async def LogStdErr(source):
	async for chunk in source:
		g_log.info(chunk)

async def SendStdOut(source, dest, bKeepAlive, done):

	if not bKeepAlive:
		nBytes = 0
		async for chunk in source:
			#log("Type: %s Len %s"%(type(chunk), len(chunk)))
			nBytes += len(chunk)
			await dest.send_message(chunk)

		g_log.info("read %d bytes from command"%nBytes)
		done.set()

	else:
		raise ValueError("Keep-alive not yet implemented")


# ########################################################################## #

async def HandleAny(request):
	'''Assume for now that all requests are data requests.  Others may be
	supported in the future, though most of the informational items are ment
	to be advertised using standard web requests not web sockets
	'''

	#g_log.info('The object type is: %s', type(request))
	g_log.info('Handler starting on path "%s"', request.path)
	#g_log.info('The full request object is: %s', dir(request))
	#g_log.info('The _event sub-object is: %s', dir(request._event))

	try:
		(sCmd, bKeepAlive) = getReaderCmd(request)
	except RequestError as e:
		await request.reject(e.status, extra_headers=e.headers, body=e.body)
		return

	ws = await request.accept()
	c_dClient.set({'ip':ws.remote.address,'port': ws.remote.port,'url':ws.remote.url})

	async with trio.open_nursery() as nursery:
		g_log.info("Running %s"%sCmd)
	
		# start a subprocessing task
		proc = await nursery.start(delegate(trio.run_process, 
			sCmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True
		))

		done = trio.Event()

		nursery.start_soon(delegate(SendStdOut, proc.stdout, ws, bKeepAlive, done))
		nursery.start_soon(delegate(LogStdErr, proc.stderr))
		nursery.start_soon(delegate(DelClientMsg, ws))

		await done.wait() # Pause here
		nursery.cancel_scope.cancel()
		

	g_log.info('Handler exiting')

# ########################################################################## #
def main(argv):
	global g_log

	psr = argparse.ArgumentParser(description='''DasFlex Websocket Server
This is a companion program for the main HTTP GET server that provides 
data via websockets.  It only handles data request.  Other requests such 
as data discovery are handled by the main server.
''')

	psr.add_argument(
		'-s', '--ssl', action='store_true', help='Comminicate within an SSL contex.'+\
		"  This option essentially makes this a 'wss' (Web Secure Socket) server "+\
		"instead of just 'ws'."
	)
	sDef = '/etc/ssl/certs/ssl-cert-snakeoil.pem'
	psr.add_argument(
		'-p', '--pem', metavar='PEM_FILE', dest="sCertFile", default=sDef,
		help="Certificate file used to validate SSL connections to the server."+\
		"  Defaults to "+sDef+"."
	)
	psr.add_argument(
		'-c', '--config', metavar="FILE", dest="sConfFile", default=g_sConfPath,
		help="Use a custom configuration file instead of %s ."%g_sConfPath
	)

	psr.add_argument(
		'host', help='Host interface to bind. If omitted, then bind all interfaces.', 
		nargs='?'
	)
	psr.add_argument(
		'port', type=int, help='Port to bind, for WSS port 443 is recommended.'
	)
	
	opts = psr.parse_args()

	logging.basicConfig(level=logging.DEBUG)
	g_log = logging.getLogger()

	if opts.ssl:
		ctxSsl = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
		try:
			ctxSsl.load_cert_chain(opts.sCertFile)
		except FileNotFoundError:
			logging.error(
				"Did not find file '%s', please specifiy an \"HTTPS\" certificate."
			)
			return 7
	else:
		ctxSsl = None
	sHost = None if opts.host == '*' else opts.host

	# Load the configuration as item 0, load others on demand

	
	logging.info('dasflex websocket server...')
	try:
		trio.run(delegate(serve_websocket, HandleAny, sHost, opts.port, ctxSsl))

	except KeyboardInterrupt:
		sys.stderr.write('CTRL-C recieved, shutting down\n')

# ########################################################################## #
if __name__ == '__main__':
	sys.exit(main(sys.argv))
